# 데이터 교환 포맷 & 시리얼라이징 리포트

## 1. 개요: 시리얼라이징과 데이터 교환 포맷

### 1.1 시리얼라이징의 정의 및 필요성  
- **시리얼라이징(serialization)**이란 메모리 상의 객체나 자료 구조를 외부 저장 또는 전송 가능한 형태(바이트 스트림이나 텍스트 포맷)로 변환하는 과정이다.  
- 반대로 이 데이터를 다시 객체나 자료 구조로 복원하는 과정을 **역직렬화(deserialization)**라 한다.  
- 시리얼라이징이 필요한 주요 이유:
  - 서로 다른 시스템이나 언어 간 데이터 교환  
  - 네트워크 통신 (클라이언트 ↔ 서버)  
  - 파일 또는 DB에 데이터 저장  
  - 메시지 큐, 로그, 캐시 등 다양한 인프라 구성 요소에 데이터 전달  

### 1.2 데이터 포맷의 역할  
- 시리얼라이징된 데이터는 단순한 바이트 시퀀스가 아니라, **구조를 명시하는 포맷**을 따라야 한다.  
- 이 구조 포맷(예: JSON, XML, YAML 등)은 데이터를 읽고 쓰는 쪽이 동일한 해석 기준을 가질 수 있게 약속하는 규격이다.  
- 좋은 데이터 포맷은 읽기 쉽고 파싱이 빠르며 오류 검출이 가능하고 확장성이 있어야 한다.

---

## 2. 주요 데이터 교환 포맷: JSON, XML, YAML

아래에서는 가장 널리 쓰이는 세 포맷(JSON, XML, YAML)을 중심으로 특징, 장단점, 사용 사례 등을 비교 정리한다.

### 2.1 JSON (JavaScript Object Notation)

#### 개요 및 특징  
- JavaScript 객체 표기법에서 유래한 경량 데이터 교환 포맷. :contentReference[oaicite:0]{index=0}  
- “키-값 쌍 (object)”과 “배열 (array)” 구조를 기본 단위로 함. :contentReference[oaicite:1]{index=1}  
- 텍스트 기반이고 대부분의 언어에서 기본 파싱/생성 기능을 갖춘 라이브러리가 존재. :contentReference[oaicite:2]{index=2}  
- 공식 규격에서는 주석을 허용하지 않는다. :contentReference[oaicite:3]{index=3}  

#### 장점  
- 가볍고 간결함 → 네트워크 전송에 효율적  
- 파싱 속도가 빠름  
- 대부분 언어 및 플랫폼에서 기본 지원  
- 구조가 직관적이어서 클라이언트-서버 통신에 적합  

#### 단점  
- 주석이 없음 → 문서화를 별도 방식으로 해야 함  
- 복잡한 메타데이터 표현에 제약  
- 날짜, 이진 데이터, 정교한 타입 표현에 제한  
- 스키마 검증 기능 내재되어 있지 않음 (JSON Schema 같은 외부 도구 필요)  

#### 사용 사례  
- REST / GraphQL API 응답/요청  
- 프론트엔드 ↔ 백엔드 통신  
- NoSQL 문서 저장 (예: MongoDB 등)  
- 로그, 이벤트 데이터 교환  

---

### 2.2 XML (eXtensible Markup Language)

#### 개요 및 특징  
- 마크업 언어의 일종으로, 태그 기반 구조로 문서를 표현하는 포맷  
- 태그와 속성(attribute)을 통해 데이터와 메타데이터를 함께 표현 가능  
- 스키마(XSD, DTD) 등을 통해 문서 구조와 제약 조건을 엄격하게 정의할 수 있다 :contentReference[oaicite:4]{index=4}  
- 문서 중심(document-centric) 데이터 표현에 적합하며, 텍스트 + 구조가 혼합된 데이터 표현 가능 :contentReference[oaicite:5]{index=5}  

#### 장점  
- 태그 기반 구조로 ‘자기 설명적(self-descriptive)’  
- 속성, 네임스페이스 등을 통해 복잡한 메타데이터 표현 가능  
- 스키마 기반 검증이 가능 → 구조적 무결성 확보  
- 기존 기업 시스템 및 표준 문서 체계와의 호환성 유지  

#### 단점  
- 태그가 많아 문서가 장황해짐  
- 파싱 비용이 크고 메모리 사용량이 높음  
- 가독성이 낮을 수 있음  
- 간단한 데이터 교환에는 과잉 설계가 될 수 있음  

#### 사용 사례  
- SOAP 기반 웹 서비스  
- 표준 문서 교환 (예: 금융, 헬스케어, B2B 시스템)  
- 기존 레거시 시스템 통합  
- 복합 문서 및 메타데이터 중심 표현  

---

### 2.3 YAML (YAML Ain’t Markup Language)

#### 개요 및 특징  
- 사람이 읽기 쉬운 직렬화 포맷을 목표로 설계됨 :contentReference[oaicite:6]{index=6}  
- 들여쓰기로 계층 구조를 표현하며, 키: 값 구조, 배열 표현 등 지원  
- JSON의 상위 집합으로 대부분의 JSON 문서를 YAML 파서로 읽을 수 있는 호환성 있음 :contentReference[oaicite:7]{index=7}  
- 앵커(anchor)와 참조(reference) 구문을 통해 같은 데이터를 재사용할 수 있음 :contentReference[oaicite:8]{index=8}  
- 주석(`#`) 지원 → 문서화 가능  

#### 장점  
- 매우 가독성이 좋고 직관적  
- 설정 파일, DevOps 도구 환경 등에 적합  
- 중복 데이터 표현을 줄이는 앵커 기능  
- JSON 형태를 포함할 수 있어 호환성 유리  

#### 단점  
- 들여쓰기 민감 → 공백 오류 발생 가능  
- 복잡한 기능이나 문법 해석이 다양해 파서별 동작 차이 존재  
- 스키마 검증 등의 기능이 상대적으로 미성숙  
- 보안 이슈 존재 (예: 임의 객체 생성 등) → `safe_load` 방식 사용 권장 :contentReference[oaicite:9]{index=9}  

#### 사용 사례  
- 설정 파일 (예: Kubernetes, Docker Compose, CI/CD 설정)  
- 인프라 구성, DevOps 스크립트  
- 사람이 자주 읽고 쓰는 구성 데이터  

---

## 3. 비교 관점별 요약

아래 표는 JSON / XML / YAML을 비교한 요약이다.

| 항목 | JSON | XML | YAML |
|------|------|-----|------|
| **가독성** | 중 | 낮 | 높 |
| **파싱 속도 & 효율성** | 빠름 | 느림 | 보통 (복잡 문법 시 느림) |
| **주석 지원** | ❌ | ✅ | ✅ |
| **메타데이터 표현** | 제한적 | 강함 (속성, 네임스페이스 등) | 어느 정도 가능하나 XML 수준은 아님 |
| **스키마/검증** | JSON Schema 등 외부 도구 | XSD / DTD 등 내장 스키마 가능 | 검증 도구 있으나 XML만큼 엄격/보편적이지 않음 |
| **구조 복잡성 표현** | 객체/배열 중심 | 태그, 속성 등 다양한 표현 가능 | 계층, 리스트, 앵커 등 유연성 있음 |
| **보안 위험** | 낮은 편 | XML 외부 엔티티(XXE) 위험 있음 | 파서 구현에 따라 위험 가능 (임의 객체 생성 등) |
| **대표 사용 분야** | API, 웹 통신 | 문서 중심 시스템, 레거시 통합 | 설정 파일, DevOps, 환경 구성 등 |

---

## 4. 확장 포맷 및 보조 기술

- **Binary XML / EXI**  
  XML의 단점을 보완하기 위한 이진 표현 방식 중 하나가 EXI(Efficient XML Interchange)이다. XML 문서를 보다 압축하고 빠르게 파싱할 수 있게 설계됨 :contentReference[oaicite:10]{index=10}  

- **비 JSON 기반 직렬화 포맷**  
  JSON/ XML / YAML 외에도 Protobuf, Avro, MessagePack 등 이진 직렬화 포맷이 많이 사용된다. 이런 포맷은 더 작은 크기, 빠른 파싱 등을 목표로 함 :contentReference[oaicite:11]{index=11}  

---

## 5. 결론

- JSON, XML, YAML 모두 각기 강점과 약점이 있으므로 **용도에 맞게 선택**해야 한다.  
- 웹 API 통신에는 JSON이 일반적으로 가장 적합하다  
- 설정이나 사람이 직접 다루는 구성 파일에는 YAML이 유리하다  
- 복잡한 문서 구조와 엄격한 검증이 필요한 경우에는 XML이 유리하다  
- 보안과 성능 요구사항을 고려해 파서나 검증 방식을 함께 설계해야 한다  
- 필요하다면 JSON ⇄ YAML ⇄ XML 간 변환 도구를 활용할 수 있으나, 일부 표현(주석, 속성 등)은 손실이 있을 수 있다  

